---
layout: post
title: JavaScript Application Design using Modules and MVP Pattern
date: 2014-06-14 10:33:36.000000000 +10:00
type: post
published: true
status: publish
categories:
- CSS
- Html
- Html5
- JavaScript
tags: []
meta:
  _edit_last: '2'
  _syntaxhighlighter_encoded: '1'
  _publicize_twitter_user: '@openraz'
  _wpas_done_all: '1'
  _wpas_skip_6313927: '1'
  _wpas_skip_6313920: '1'
  _wpas_skip_6313942: '1'
author:
  login: raz
  email: razibh@gmail.com
  display_name: Raz Shahriar
  first_name: Raz
  last_name: Shahriar
---
<p>Majority of websites today use JavaScript to do more than just hide or show a button. As code complexity grows, it becomes harder to understand and maintain JavaScript code. In this example, two approaches of designing an application will be contrasted to highlight the benefits of a modular design. Although the example is a simple game application, it still demonstrates how breaking an application into loosely coupled modules makes it easy to understand, extend and maintain.</p>
<h2>Designing a Path Finding Game</h2>
<p><strong>Requirements</strong>: The purpose of the application is to demonstrate different path finding algorithms for a game that involves a cat looking for a cake on an interactive board. The user can draw obstacles on the board by clicking on the tiles, and move the cat or cake to set its positions. The game can then determine a path that allows the cat to find the cake when a "Find Path" button is pressed. This is how the end result may look like:</p>
<p><a href="http://ce5.ed6.myftpupload.com/wp-content/uploads/2014/07/cat.png"><img class="alignnone wp-image-278 size-full" src="{{ site.baseurl }}/assets/cat.png" alt="Pathfinder App" width="505" height="520" /></a></p>
<p>&nbsp;</p>
<h2>Classic Approach</h2>
<p>Using a classic JavaScript design approach, we can do the following:</p>
<ul>
<li>Use divs to represent the board and the actors, which are then manipulated using <strong>jQuery</strong></li>
<li>Assign a CSS class to a div to represent various elements of the game:
<ul>
<li>an empty square - <span class="lang:java decode:true  crayon-inline ">.square</span></li>
<li>a square with an obstacle  - <span class="lang:java decode:true crayon-inline">.obstacle</span></li>
<li>a square with the actor cat - <span class="lang:java decode:true crayon-inline">.actor</span></li>
<li>a square with the goal cake - <span class="lang:java decode:true crayon-inline">.goal</span></li>
</ul>
</li>
<li>Write a function that will query the divs using jQuery class selectors to find the positions of the cat and cake to determine the solution</li>
</ul>
<p>In such approach, the view state and application state may get mixed together - as there are no clear separation between model and view.  The setup code for the board might look like:</p>
<pre class="lang:js decode:true">// generate the board layout consisting of squares
for (var row = 0; row &lt; rows; row++) {
    for (var col = 0; col &lt; cols; col++) {
        $('div.board').append('&lt;div class="square" row="' + row + '" col="' + col + '"&gt;&lt;/div&gt;')
    }
}

// toggle between obstacle and open when a square is clicked
$('div.board').find(".square").click(function () {
    $(this).toggleClass('obstacle')		
})</pre>
<p>When the game's actor cat is dropped on a square to specify a starting position, the class attributes of the divs are updated:</p>
<pre class="lang:java decode:true">// when the actor is dropped on a square
$('.square').droppable(function() {
     $('.actor').removeClass('actor')
     $(this).addClass('actor')
})
</pre>
<p>In this design, the code to move an actor to the square at position [10,15] may look like:</p>
<pre class="lang:js decode:true">var isObstacle = $('.square[row=10][col=15]').hasClass('obstacle')
if (!isObstacle) {
     $('div.actor').removeClass('actor')
     $('.square[row=10][col=15]').addClass('actor')
}</pre>
<p>Next step would be to implement the path finding algorithm. Without going any further, we can already start to notice that most of our code is entangled with jQuery. Such code may look simplistic at first, but it is hard to maintain as application logic is diffused with DOM manipulations. With time, it will become harder to follow how everything fits together - as everything is glued together with CSS selectors and callbacks.</p>
<p>This monolithic approach makes it hard to write reusable code as most functions are littered with view specific jQuery code. If we have to change how the view is generated, we would have to change many places of the code - we may even miss a few places.</p>
<p>&nbsp;</p>
<h2>Alternative Modular Approach</h2>
<p>We can start by identifying clusters of functions or objects that relate closely to a single domain concept. Also, we would like to separate the concerns of displaying the board/actors from the Game so that there is a clean separation between view and business logic. Thus, we come up with:</p>
<ul>
<li><strong>Board</strong> - Represents a Grid containing open tiles and obstacles</li>
<li><strong>Actor</strong> - Represents the actor of the game - the Cat</li>
<li><strong>Game</strong> - Co-ordinates the elements and rules of the game</li>
<li><strong>Game-View</strong> - Visualising the state of the game.</li>
<li><strong>Solver Service</strong> - A service or strategy to find a path from the Actor to the goal  on the board. This could also be a remote service using AJAX.</li>
</ul>
<p>We can map these cluster of functions or objects into modules. This will allow us to clearly mark the boundaries and dependencies between different parts of our application.</p>
<p>Identifying the specific roles of objects allow us to apply a design pattern like MVC or MVP to glue the loosely coupled parts together. In this example, the Game object performs the role of the <strong>Presenter</strong> and the Board/Actor objects together comprise the <strong>Model</strong>. All V<strong>iew</strong> concerns are encapsulated in the Game-View module. The following illustration shows the relationship between the application objects:</p>
<p><a href="http://ce5.ed6.myftpupload.com/wp-content/uploads/2014/07/pathfinder.png"><img class="alignnone wp-image-281 size-full" src="{{ site.baseurl }}/assets/pathfinder.png" alt="pathfinder" width="730" height="430" /></a></p>
<p>&nbsp;</p>
<p>With such separation of concerns and single responsibility, the code to move the actor to a square will look like:</p>
<pre class="lang:java decode:true">if (board.isValidMove(position)) {
    actor.setPosition(position)
    gameView.updateActor(position)
}</pre>
<p>Any interaction that happens in the view is handled by the Game Presenter:</p>
<pre class="lang:js decode:true">// Inside Game Presenter
// View object - Pass Presenter callbacks for event handling
var gameView = new GameView(options, {
    onObstacleChange : function(isObstacle, row, col) {
        board.setObstacle(isObstacle, row, col)
        gameView.reset()
    },
    onNewStartPosition: function(row, col) {
        actorPos = new Position(row, col)
        gameView.reset()
    },
    onNewGoalPosition: function(row, col) {
        goalPos = new Position(row, col)
        gameView.reset()
    }
})</pre>
<p>The modular design allows us to load different Service/Strategies for solving the game - which may be loaded lazily as required:</p>
<pre class="lang:java decode:true">// Solver Service returns a list of moves that leads the cat to the cake
var solution = SolverService.solve(board, actorPos, goalPos)
solution.forEach(function(position) {
    game.moveActor(position)
})</pre>
<p>In summary, the modular design allows us to create reusable components that can be easily tested and maintained. Application logic is cleanly isolated from view/DOM manipulation logic as we have moved all jQuery code into our view module. This makes the code much easier to comprehend. Since the dependencies between modules can be explicitly defined, the runtime can load modules in parallel to reduce application load time.</p>
<p>If you would like to play with the sample application, please find it here: <a href="https://github.com/openraz/javascript/tree/master/pathfinder" target="_blank">https://github.com/openraz/javascript/tree/master/pathfinder</a></p>
<pre class="lang:java decode:true ">git clone https://github.com/openraz/javascript.git</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
